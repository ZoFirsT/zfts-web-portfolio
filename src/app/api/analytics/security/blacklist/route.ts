import { NextRequest, NextResponse } from 'next/server';
import { connectToDatabase } from '@/lib/mongodb';
import { jwtVerify } from 'jose';

// Mark this route as dynamic to fix the build error
export const dynamic = 'force-dynamic';

// List the most recent 3 months of attacks
const LOOKBACK_TIME = 90 * 24 * 60 * 60 * 1000; // 90 days in milliseconds

/**
 * Helper to generate IP blacklist in various formats
 */
async function generateBlacklist(format: string): Promise<{ content: string, contentType: string }> {
  const { db } = await connectToDatabase();
  
  // Get all blocked IPs from the last 90 days
  const startDate = new Date(Date.now() - LOOKBACK_TIME);
  
  const blockedIPsResult = await db.collection('analytics_ddos').aggregate([
    { $match: { timestamp: { $gte: startDate }, blocked: true } },
    { $group: { _id: '$ip', count: { $sum: 1 }, lastSeen: { $max: '$timestamp' } } },
    { $sort: { count: -1 } },
    {
      $project: {
        _id: 0,
        ip: '$_id',
        count: 1,
        lastSeen: 1
      }
    }
  ]).toArray();
  
  // Filter out invalid IPs for safety
  const blockedIPs = blockedIPsResult.filter(item => {
    // Basic IP validation
    return item.ip && /^(\d{1,3}\.){3}\d{1,3}$/.test(item.ip);
  });
  
  let content = '';
  let contentType = 'text/plain';
  
  // Generate content based on requested format
  switch (format) {
    case 'json':
      content = JSON.stringify(blockedIPs, null, 2);
      contentType = 'application/json';
      break;
      
    case 'csv':
      content = 'IP,AttackCount,LastSeen\n';
      blockedIPs.forEach(item => {
        content += `${item.ip},${item.count},${new Date(item.lastSeen).toISOString()}\n`;
      });
      contentType = 'text/csv';
      break;
      
    case 'apache':
      content = '# Apache Deny Rules for Malicious IPs\n';
      content += '# Generated by ZFTS Portfolio Security at ' + new Date().toISOString() + '\n\n';
      blockedIPs.forEach(item => {
        content += `Deny from ${item.ip} # ${item.count} attacks, last seen ${new Date(item.lastSeen).toLocaleDateString()}\n`;
      });
      contentType = 'text/plain';
      break;
      
    case 'nginx':
      content = '# Nginx Deny Rules for Malicious IPs\n';
      content += '# Generated by ZFTS Portfolio Security at ' + new Date().toISOString() + '\n\n';
      blockedIPs.forEach(item => {
        content += `deny ${item.ip}; # ${item.count} attacks, last seen ${new Date(item.lastSeen).toLocaleDateString()}\n`;
      });
      contentType = 'text/plain';
      break;
      
    case 'txt':
    default:
      content = '# Blocked IP List\n';
      content += '# Generated by ZFTS Portfolio Security at ' + new Date().toISOString() + '\n\n';
      blockedIPs.forEach(item => {
        content += `${item.ip} # ${item.count} attacks, last seen ${new Date(item.lastSeen).toLocaleDateString()}\n`;
      });
      contentType = 'text/plain';
  }
  
  return { content, contentType };
}

// Function to check if a request is from an authenticated user
// We'll make blacklists accessible to everyone for the open source initiative
async function isAuthenticated(request: NextRequest): Promise<boolean> {
  // For blacklists, we're making this public as part of our open-source security initiative
  return true;
  
  /* Authentication code kept for reference
  const token = request.cookies.get('auth-token');
  if (!token) return false;
  
  try {
    const secretKey = process.env.JWT_SECRET || 'your-secret-key';
    const key = new TextEncoder().encode(secretKey);
    await jwtVerify(token.value, key);
    return true;
  } catch (error) {
    return false;
  }
  */
}

export async function GET(request: NextRequest) {
  // Check authentication - could be removed if you want public access to the blacklist
  if (!await isAuthenticated(request)) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }
  
  try {
    // Get format from query parameters
    const searchParams = request.nextUrl.searchParams;
    const format = searchParams.get('format') || 'txt';
    
    // Only allow these formats
    if (!['txt', 'json', 'csv', 'apache', 'nginx'].includes(format)) {
      return NextResponse.json(
        { error: 'Invalid format' },
        { status: 400 }
      );
    }
    
    // Generate the blacklist
    const { content, contentType } = await generateBlacklist(format);
    
    // Set the filename based on format
    let filename = '';
    switch (format) {
      case 'json': filename = 'ip-blacklist.json'; break;
      case 'csv': filename = 'ip-blacklist.csv'; break;
      case 'apache': filename = 'apache-deny.conf'; break;
      case 'nginx': filename = 'nginx-deny.conf'; break;
      default: filename = 'ip-blacklist.txt';
    }
    
    // Return the file as a downloadable attachment with open source indicators
    return new NextResponse(content, {
      headers: {
        'Content-Type': contentType,
        'Content-Disposition': `attachment; filename=${filename}`,
        'X-Security-Data-Source': 'ZFTS-OpenSource-SecurityInitiative',
        'X-License-Type': 'CC-BY-SA-4.0', // Creative Commons Attribution-ShareAlike 4.0 International
        'Access-Control-Allow-Origin': '*' // Allow cross-origin access for the open source data
      }
    });
  } catch (error) {
    console.error('Failed to generate blacklist:', error);
    return NextResponse.json(
      { error: 'Failed to generate blacklist' },
      { status: 500 }
    );
  }
}
